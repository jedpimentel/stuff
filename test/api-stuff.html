<!DOCTYPE html>
<html lang="eng">

<head>
  <title>API STUFF</title>
  <meta charset="utf-8">


  <script src="https://aframe.io/releases/0.8.2/aframe.min.js"></script>
  <script src="../lib/jose-components.js"></script>

</head>

<body style="font-family:courier; color:white; background-color: black">



  <a-scene loading-screen="dotsColor: white; backgroundColor: black">

    <a-entity joses-default-interface="mode: wasd"></a-entity>


    <a-plane voxel-board class="clickable" color="gray" position="0 0 -4" height="8" width="8"></a-plane>

    <!-- phone browser was starting looking backwards (rotated 180 dex on y-axis) -->
    <!-- was easier to just include another board than to find out why (for now) -->
    <a-plane voxel-board class="clickable" color="gray" position="0 0 4" rotation="0 180 0" height="8" width="8"></a-plane>
    <!-- <a-plane voxel-board class="clickable" color="white" position="0 0 -4" rotation="-90 0 0" height="8" width="8"></a-plane> -->


    <a-box id="reset-button" class="clickable" position="4 0 0" rotation="0 -90 0" color="green" opacity="0.2">
      <a-text value="RESET" align="center" side="double"></a-text>
    </a-box>
    <script type="text/javascript">
      {
        let button = document.querySelector("#reset-button")
        button.addEventListener("click", () => {
          // window.location.href = 'https://supermedium.com/supercraft/';
          window.location.href = './cage.html';
        }); 
      }
    </script>

    <!-- <a-box id="next" class="clickable" position="1.5 1 -4" color="green" opacity="0.2">
      <a-text value="NEXT" align="center" side="double"></a-text>
    </a-box> -->
    <a-entity cubeez position="-1.5 1 -4"></a-entity>



    <!-- <a-cylinder id='green-cyl' class="clickable" position="6.5 .75 -8" radius="0.5" color="green" opacity="0.3"></a-cylinder> -->

  </a-scene>

  <script type="text/javascript">

    // GET TEST
    // "https://postman-echo.com/get?foo1=bar1&foo2=bar2"

    const url1 = "https://postman-echo.com/get?foo1=bar1&foo2=bar2"
    const url2 = 'https://jsonplaceholder.typicode.com/todos/1'
    // SimpleHTTPServer

    // hosted locally via:
    //   http-server -c-1--cors

    // url (required), options (optional)
    // fetch('https://davidwalsh.name/some/url', {
    // fetch("https://postman-echo.com/get?foo1=bar1&foo2=bar2", {
    //   method: 'get',
    //   mode: 'no-cors',
    // }).then(function(response) {
    //   console.log(response);
      
    // }).catch(function(err) {
    //   console.log(err);
    //   // Error :(
    // });



    // fetch("https://postman-echo.com/get?foo1=bar1&foo2=bar2", {
    //   method: 'get',
    //   mode: 'no-cors',
    // }).then(function(response) {
    //   console.log(response);
      
    // }).catch(function(err) {
    //   console.log(err);
    //   // Error :(
    // });

    // fetch(url2)
    // .then(response => response.json())// somehow needs this extra step instead of logging directly
    // .then(json => console.log(json))


    //// W-O-R-K-I-N-G-!-!-!-

    const HUBSPOT_GET = "https://candidate.hubteam.com/candidateTest/v3/problem/dataset?userKey=3ce49820855f14f765b1237ff770"
    const HUBSPOT_POST = "https://candidate.hubteam.com/candidateTest/v3/problem/result?userKey=3ce49820855f14f765b1237ff770"
    const MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000

    // fetch(url2, {
    fetch(HUBSPOT_GET, {
      // method: 'get',
      // mode: 'cors',
    })
    // .then(response => response.json())// somehow needs this extra step instead of logging directly
    .then(response => {
      if (!response.ok) {
        console.error(response)
      }
      // response.json()
      return response.json()
    })
    .then(json => {
      console.log(json)
      const partnerData = json.partners

      // group available dates by county
      // key=country Value=availableDates

      // rename "fisrt dates" to "startDates"

      const partnersByCountry = {};

      const daysByCountry = {};//dayCountByCountry is meant to replace this
      const dayCountByCountry = {};// move to: {Country: {dayA: count, dayB: count}}
      const partnerEmailByDate = {};//available that day & the next
      const partnerEmailByDateByCountry = {};//available that day & the next
      const partnerEmailByDateAllowSingle = {};//available that day & the next

      // const daysByCountry = new Map();
      partnerData.forEach(p => {
        const country = p.country;

        // inneficient to check each iter?
        if (!dayCountByCountry.hasOwnProperty(country)) dayCountByCountry[country] = {}


        if (!partnersByCountry.hasOwnProperty(country)) partnersByCountry[country] = [];
        partnersByCountry[country].push(p)

        if (!partnerEmailByDateByCountry.hasOwnProperty(country)) partnerEmailByDateByCountry[country] = {}


        // inclusive list stuff
        {
          if (!partnerEmailByDateAllowSingle.hasOwnProperty(country)) partnerEmailByDateAllowSingle[country] = {};
          // else partnerEmailByDateAllowSingle[country].push(p)
        }



        // const datesObj = {};//day

        // only count the dates where they can also show up the next day
        const dates = [];//partner available this day and the next
        for (let i = 0; i < p.availableDates.length; i++) {

          const date = p.availableDates[i]

          // add people to inclusive list that also has peeps that can only make it one day
          {
            // const date = p.availableDates[i]
            // dates.push(date)

            // if (partnerEmailByDateAllowSingle[country].hasOwnProperty(date)) partnerEmailByDateAllowSingle[country][date]++
            // else partnerEmailByDateAllowSingle[country][date] = 1

            // if (partnerEmailByDate[date]) partnerEmailByDate[date].push(p.email);
            // else partnerEmailByDate[date] = [p.email]
          }
          if (partnerEmailByDateByCountry[country].hasOwnProperty(date)) partnerEmailByDateByCountry[country][date].push(p.email)
          else partnerEmailByDateByCountry[country][date] = [p.email]

          // break loop if this condition is left, rest of logic only applis to fist+second day stuff
          if (!(i < p.availableDates.length-1)) break;

          const first = Date.parse(p.availableDates[i]) / MILLISECONDS_PER_DAY
          const second = Date.parse(p.availableDates[i+1]) / MILLISECONDS_PER_DAY
          // console.log(first)


          if (second - first < 1.2) {// zoidberg
            const date = p.availableDates[i]
            dates.push(date)

            if (dayCountByCountry[country].hasOwnProperty(date)) dayCountByCountry[country][date]++
            else dayCountByCountry[country][date] = 1

            if (partnerEmailByDate[date]) partnerEmailByDate[date].push(p.email);
            else partnerEmailByDate[date] = [p.email]
          }
        }


        if (daysByCountry.hasOwnProperty(country)) daysByCountry[country].push(...dates);
        else daysByCountry[country] = dates;
      })

      // ISO 8601 date strings are pretty stable 
      for (const days of Object.values(daysByCountry)) days.sort();

      // I'm assuming it's the same for two people going on one day 

      console.log(daysByCountry)
      console.log(' ')
      console.log('partnerEmailByDate', partnerEmailByDate)
      console.log(' ')
      console.log('dayCountByCountry', dayCountByCountry)
      console.log('partnerEmailByDateAllowSingle', partnerEmailByDateAllowSingle)
      console.log('partnerEmailByDateByCountry', partnerEmailByDateByCountry)

      const bestDayByCountry = {}
      const response = []
      for (let [country, partnersPerDate] of Object.entries(dayCountByCountry)) {

        const peopleThatCanMakeIt = partnersPerDate

        const bestDate = dateWithMost(peopleThatCanMakeIt)
        bestDayByCountry[country] = bestDate
        response.push({
          // "attendeeCount": partnerEmailByDate[bestDate].length,
          // "attendees": partnerEmailByDate[bestDate],
          "attendeeCount": partnerEmailByDateByCountry[country][bestDate].length,
          "attendees": partnerEmailByDateByCountry[country][bestDate],
          "name": country,
          "startDate": bestDate
        })
      }

      console.log(bestDayByCountry)
      console.log('response:', response)

      console.log('partnersByCountry', partnersByCountry)
      // DEBUG ZONE
      console.log(dateStringToDayYear(partnersByCountry.Canada[0].availableDates[0]))


      chuckResponseIntoPit({"countries": response})
    })


    function parsePartnerData(partnerData) {
      ;
    }

    //assumes dates are ordered?
    function dateWithMost(dateHeadCountObj) {
      let mostPeople = 0;
      let date = null;
      for (let [dateString, headcount] of Object.entries(dateHeadCountObj))  {

        if (headcount > mostPeople) {
          mostPeople = headcount
          date = dateString
        }

      }
      return date
    }


    function chuckResponseIntoPit(res) {
      fetch(HUBSPOT_POST, {
          method: 'post',
          // mode: 'cors',

          headers: {
            'Content-Type': 'application/json'
            // 'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: JSON.stringify(res)
      })
      // .then(response => response.json())// somehow needs this extra step instead of logging directly
      .then(response => {
        if (!response.ok) {
          console.log('\nNOT OK /////////////////\n')
          console.error(response)
        }
        // response.json()
        return response.json()
      })
      .then(json => {
          console.log('\nOK\n')
          console.log(json)
      })
    }

    // debug tool
    function dateStringToDayYear(dStr) {
      return (Date.parse(dStr) - Date.parse('2017-04-01')) / MILLISECONDS_PER_DAY
      // return 
    }

    // function

    // POST TEST
    // POST TEST
    // const post_url = 'http://postman-echo.com/post'
    // fetch(post_url, {
    //     method: 'post',
    //     // mode: 'cors',

    //     headers: {
    //       'Content-Type': 'application/json'
    //       // 'Content-Type': 'application/x-www-form-urlencoded',
    //     },
    //     body: {
    //         this: 'thaty'
    //     }
    // })
    // // .then(response => response.json())// somehow needs this extra step instead of logging directly
    // .then(response => {
    //   if (!response.ok) {
    //     console.log('\nNOT OK /////////////////\n')
    //     console.error(response)
    //   }
    //   // response.json()
    //   return response.json()
    // })
    // .then(json => {
    //     console.log('\nOK\n')
    //     console.log(json)
    // })





// If your answer is correct, the API will return 200 OK. If the request is malformatted or incorrect, the API will return 400 along with a message indicating if the response is of the wrong structure or incorrect.

// If you get a 5xx response, let us know and weâ€™ll help you out.

// The candidate.hubteam.com domain is set up with a permissive cross-origin policy, so you can POST to it from any location in a browser if you choose to implement in an in-browser JS solution.



    
    // try {
    //   const data = await postData('http://example.com/answer', { answer: 42 });
    //   console.log(JSON.stringify(data)); // JSON-string from `response.json()` call
    // } catch (error) {
    //   console.error(error);
    // }

    // async function postData(url = '', data = {}) {
    //   // Default options are marked with *
    //   const response = await fetch(url, {
    //     method: 'POST', // *GET, POST, PUT, DELETE, etc.
    //     mode: 'cors', // no-cors, *cors, same-origin
    //     cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    //     credentials: 'same-origin', // include, *same-origin, omit
    //     headers: {
    //       'Content-Type': 'application/json'
    //       // 'Content-Type': 'application/x-www-form-urlencoded',
    //     },
    //     redirect: 'follow', // manual, *follow, error
    //     referrer: 'no-referrer', // no-referrer, *client
    //     body: JSON.stringify(data) // body data type must match "Content-Type" header
    //   });
    //   return await response.json(); // parses JSON response into native JavaScript objects
    // }

  </script>

</body>
</html>